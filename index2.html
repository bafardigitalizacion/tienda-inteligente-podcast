<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#0066cc">
    <title>Reproductor de Podcast - Tienda Inteligente</title>
    <style>
        /* Estilos CSS (Variables y base sin cambios) */
        :root {
            --primary-color: #0066cc;
            --secondary-color: #e6f0ff;
            --text-color: #333;
            --background-color: #f0f5ff;
            --progress-color: #3498db; /* Color normal de progreso */
            --loading-color: #a0c0e0; /* Color durante la carga */
            --error-color: #e74c3c; /* Color para errores */
            --error-bg-color: #fdd; /* Fondo para errores */
        }

        body, html {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--background-color);
            margin: 0;
            padding: 0;
            color: var(--text-color);
            height: 100%;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            width: 100%;
            max-width: 600px;
            margin: 20px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .header {
            background-color: var(--primary-color);
            color: white;
            padding: 18px 20px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .player-container {
            padding: 25px;
        }

        .player-info {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
        }

        .podcast-image {
            width: 70px;
            height: 70px;
            background-color: var(--secondary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            color: var(--primary-color);
            font-size: 24px;
            box-shadow: 0 3px 10px rgba(0, 102, 204, 0.2);
            transition: transform 0.2s;
            flex-shrink: 0;
        }

        .podcast-image:hover {
            transform: scale(1.05);
        }

        .podcast-details {
            flex-grow: 1;
            min-width: 0;
        }

        .podcast-title {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .podcast-date {
            color: #777;
            font-size: 0.9rem;
        }

        .player-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- Estilos para Indicadores de Carga --- */
        #waveform {
            margin: 15px 0;
            height: 60px;
            width: 100%;
            position: relative; /* Necesario para el pseudo-elemento */
            background-color: #f0f0f0; /* Fondo mientras carga */
            border-radius: 3px;
            overflow: hidden;
        }
        /* Animación de puntos suspensivos en el área de la onda */
        #waveform.loading::before {
            content: '...';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            color: var(--primary-color);
            animation: dots 1.5s infinite linear;
        }
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        /* Ocultar el contenido real de wavesurfer mientras carga */
        #waveform.loading > wave {
             opacity: 0;
        }


        .progress-container {
            background-color: #eee;
            border-radius: 5px;
            height: 6px;
            position: relative;
            cursor: pointer;
            transition: height 0.2s;
            width: 100%;
            overflow: hidden;
        }
        .progress-container:hover {
            height: 8px;
        }

        .progress-bar {
            background-color: var(--progress-color);
            height: 100%;
            border-radius: 5px;
            width: 0%;
            transition: width 0.1s linear;
            display: block;
        }
        /* Estilo animado para la barra de progreso durante la carga */
        .progress-bar.loading {
            background-color: var(--loading-color);
            background-image: linear-gradient(45deg, rgba(255, 255, 255, .15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
            animation: progress-bar-stripes 1s linear infinite;
            /* La anchura (width) la sigue controlando el evento 'loading' de JS */
        }
         /* Estilo para error en barra de progreso */
         .progress-bar.error {
             background-color: var(--error-color);
             width: 100%; /* Llenar la barra en caso de error */
             animation: none; /* Detener animación si la había */
         }

        @keyframes progress-bar-stripes {
            from { background-position: 1rem 0; }
            to { background-position: 0 0; }
        }
        /* --- Fin Estilos Indicadores de Carga --- */


        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: #666;
             padding: 0 5px;
        }

        .control-buttons {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 10px;
        }

        .volume-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
        }

        .volume-button {
            background: none;
            border: none;
            cursor: pointer;
            color: var(--primary-color);
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s, transform 0.2s;
        }
        .volume-button:hover {
            background-color: var(--secondary-color);
            transform: scale(1.1);
        }
        .volume-button svg {
             width: 20px;
             height: 20px;
        }

        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 4px;
            border-radius: 2px;
            background: #ddd;
            outline: none;
            transition: all 0.2s;
            cursor: pointer;
        }
        .volume-slider:hover { height: 5px; }
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px; height: 14px; border-radius: 50%;
            background: var(--primary-color); cursor: pointer; transition: all 0.2s;
        }
        .volume-slider::-webkit-slider-thumb:hover { transform: scale(1.2); box-shadow: 0 0 5px rgba(0, 102, 204, 0.5); }
        .volume-slider::-moz-range-thumb {
            width: 14px; height: 14px; border-radius: 50%;
            background: var(--primary-color); cursor: pointer; border: none; transition: all 0.2s;
        }
         .volume-slider::-moz-range-thumb:hover { transform: scale(1.2); box-shadow: 0 0 5px rgba(0, 102, 204, 0.5); }

        .play-button {
            background-color: var(--primary-color); color: white; border: none;
            width: 60px; height: 60px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 102, 204, 0.3); flex-shrink: 0;
        }
         .play-button svg { width: 24px; height: 24px; }
        .play-button:hover { background-color: #0055aa; transform: scale(1.08); box-shadow: 0 6px 15px rgba(0, 85, 170, 0.4); }
        .play-button:active { transform: scale(0.95); background-color: #004488; box-shadow: 0 2px 8px rgba(0, 68, 136, 0.3); }
         /* Botón deshabilitado */
         .play-button:disabled {
             background-color: var(--loading-color); /* Usar color de carga */
             cursor: not-allowed; opacity: 0.7; box-shadow: none; transform: none;
         }
         .play-button:disabled:hover { background-color: var(--loading-color); transform: none; box-shadow: none; }

        .archive-section { margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px; }
        .archive-title { font-weight: bold; margin-bottom: 15px; font-size: 1.1rem; color: var(--primary-color); padding-left: 5px; }
        .archive-list {
            list-style: none; padding: 0; margin: 0; max-height: 150px;
            overflow-y: auto; border: 1px solid #eee; border-radius: 8px;
        }
        .archive-item {
            padding: 12px 15px; border-bottom: 1px solid #eee; cursor: pointer;
            transition: all 0.2s ease; display: flex; align-items: center;
        }
         .archive-item:last-child { border-bottom: none; }
        .archive-item.not-available { color: #999; cursor: not-allowed; text-decoration: line-through; background-color: #f9f9f9; }
        .archive-item.not-available:hover { background-color: #f9f9f9; transform: none; }
        .archive-item:hover:not(.not-available) { background-color: var(--secondary-color); transform: translateX(5px); color: var(--primary-color); }
         .archive-item:hover:not(.not-available) .archive-item-icon { color: var(--primary-color); }
        .archive-item-icon { margin-right: 15px; color: var(--primary-color); flex-shrink: 0; }
         .archive-item-icon svg { width: 16px; height: 16px; }
        .archive-item-date { font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; flex-grow: 1; }
         .archive-item.active { background-color: var(--secondary-color); color: var(--primary-color); font-weight: bold; }
         .archive-item.active .archive-item-icon { color: var(--primary-color); }

        .error-message {
            color: var(--error-color); font-size: 0.9rem; margin-top: 10px;
            display: none; text-align: center; padding: 8px;
            background-color: var(--error-bg-color); border: 1px solid var(--error-color); border-radius: 5px;
        }

        /* Media Queries (sin cambios) */
        @media (max-width: 480px) {
            .container { width: 95%; margin: 10px auto; border-radius: 10px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); }
            .player-container { padding: 20px; }
            .player-info { flex-direction: row; align-items: center; margin-bottom: 20px; }
            .podcast-image { width: 60px; height: 60px; margin-right: 12px; font-size: 20px; }
             .podcast-title { font-size: 1rem; }
             .podcast-date { font-size: 0.85rem; }
            .play-button { width: 55px; height: 55px; }
             .play-button svg { width: 22px; height: 22px; }
            #waveform { height: 50px; }
             .volume-controls { gap: 8px; }
             .volume-slider { width: 80px; }
             .archive-list { max-height: 120px; }
             .archive-item { padding: 10px 12px; }
        }
    </style>
    <script src="https://unpkg.com/wavesurfer.js@6/dist/wavesurfer.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            Tienda Inteligente - Reporte Semanal
        </div>
        <div class="player-container">
            <div class="player-info">
                <div class="podcast-image">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="22"></line></svg>
                </div>
                <div class="podcast-details">
                    <div class="podcast-title" id="podcast-title">Resumen del Reporte Semanal</div>
                    <div class="podcast-date" id="podcast-date">Cargando...</div>
                    <div class="error-message" id="error-message"></div>
                </div>
            </div>

            <div id="waveform"></div>

            <div class="player-controls">
                <div class="progress-container" id="progress-container" title="Haz clic para avanzar/retroceder">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
                <div class="time-display">
                    <span id="current-time">00:00</span>
                    <span id="duration">00:00</span>
                </div>
                <div class="control-buttons">
                    <button class="play-button" id="play-button" aria-label="Reproducir/Pausar" disabled title="Cargando audio y onda...">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" id="play-icon"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" id="pause-icon" style="display: none;"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                    </button>
                </div>
                <div class="volume-controls">
                     <button class="volume-button" id="mute-button" aria-label="Silenciar/Activar Sonido" title="Silenciar/Activar Sonido">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" id="volume-icon">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <path d="M15.54 8.46a5 5 0 0 1 0 7.07" id="volume-low" style="display: none;"></path>
                            <path d="M19.07 4.93a10 10 0 0 1 0 14.14" id="volume-high" style="display: block;"></path>
                        </svg>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" id="mute-icon" style="display: none;">
                            <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                            <line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>
                        </svg>
                    </button>
                    <input type="range" min="0" max="1" step="0.01" value="1" class="volume-slider" id="volume-slider" aria-label="Control de volumen" title="Ajustar volumen">
                </div>
            </div>

            <div class="archive-section">
                <div class="archive-title">Resúmenes anteriores</div>
                <ul class="archive-list" id="archive-list">
                    <li class="archive-item">Buscando resúmenes disponibles...</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- Referencias a elementos del DOM ---
            const playButton = document.getElementById('play-button');
            const playIcon = document.getElementById('play-icon');
            const pauseIcon = document.getElementById('pause-icon');
            const progressBar = document.getElementById('progress-bar');
            const progressContainer = document.getElementById('progress-container');
            const currentTimeDisplay = document.getElementById('current-time');
            const durationDisplay = document.getElementById('duration');
            const podcastTitleDisplay = document.getElementById('podcast-title');
            const podcastDateDisplay = document.getElementById('podcast-date');
            const archiveList = document.getElementById('archive-list');
            const muteButton = document.getElementById('mute-button');
            const volumeIcon = document.getElementById('volume-icon');
            const muteIcon = document.getElementById('mute-icon');
            const volumeSlider = document.getElementById('volume-slider');
            const volumeLow = document.getElementById('volume-low');
            const volumeHigh = document.getElementById('volume-high');
            const errorMessage = document.getElementById('error-message');
            const waveformContainer = document.getElementById('waveform'); // Div contenedor

            // --- Estado del reproductor ---
            let wavesurfer;
            let isPlaying = false;
            let isMuted = false;
            let currentPodcastInfo = null;
            let previousVolume = 1;

            // --- Inicialización de WaveSurfer ---
            function initWaveSurfer() {
                if (wavesurfer) { wavesurfer.destroy(); }

                wavesurfer = WaveSurfer.create({
                    container: waveformContainer, // Usar el div #waveform
                    waveColor: '#cccccc',
                    progressColor: 'var(--primary-color)',
                    cursorWidth: 1, cursorColor: '#333', height: 60,
                    barWidth: 2, barGap: 1, responsive: true, normalize: true,
                    backend: 'MediaElement',
                });

                // --- Eventos de WaveSurfer ---

                wavesurfer.on('loading', function (percent) {
                    // Actualizar barra de progreso durante la descarga
                    progressBar.style.width = `${percent}%`;
                    // Mantener estilo 'loading' (rayas animadas y color)
                    progressBar.classList.add('loading');
                    waveformContainer.classList.add('loading'); // Mostrar puntos suspensivos
                });

                wavesurfer.on('ready', function() {
                    // Audio y onda listos
                    console.log("WaveSurfer ready for:", currentPodcastInfo?.filename);
                    durationDisplay.textContent = formatTime(wavesurfer.getDuration());
                    const initialVolume = parseFloat(volumeSlider.value);
                    wavesurfer.setVolume(initialVolume);
                    updateVolumeIcon();
                    playButton.disabled = false; // HABILITAR PLAY
                    playButton.title = "Reproducir/Pausar";
                    errorMessage.style.display = 'none';

                    // --- Quitar indicadores de carga ---
                    progressBar.classList.remove('loading');
                    progressBar.classList.remove('error'); // Quitar posible estado de error previo
                    progressBar.style.width = '0%'; // Reiniciar barra visual
                    waveformContainer.classList.remove('loading'); // Ocultar puntos suspensivos

                    currentTimeDisplay.textContent = '00:00';

                    // Actualizar título principal
                     if (currentPodcastInfo) {
                         let title = "Resumen";
                         const filenameWithoutExt = currentPodcastInfo.filename.replace(/\.mp3$/, '');
                         const datePatternMatch = filenameWithoutExt.match(/(\d{2}\.\d{2}\.\d{4})$/);
                         let baseName = filenameWithoutExt;
                         if (datePatternMatch) {
                             baseName = filenameWithoutExt.substring(0, datePatternMatch.index).replace(/_$/, '');
                         }
                         if (baseName) {
                              title = baseName.replace(/_/g, ' ');
                              title = title.charAt(0).toUpperCase() + title.slice(1);
                         } else { title = "Resumen Semanal"; }
                         podcastTitleDisplay.textContent = title;
                     }
                });

                wavesurfer.on('audioprocess', function() {
                    // Actualizar tiempo y barra durante reproducción
                    if (!progressBar.classList.contains('loading')) { // No actualizar si aún carga
                        const currentTime = wavesurfer.getCurrentTime();
                        currentTimeDisplay.textContent = formatTime(currentTime);
                        const duration = wavesurfer.getDuration();
                        if (typeof duration === 'number' && duration > 0) {
                            const percentage = (currentTime / duration) * 100;
                            progressBar.style.width = `${Math.min(percentage, 100)}%`;
                        }
                    }
                });

                wavesurfer.on('seek', function() {
                     // Actualizar tiempo y barra al buscar manualmente
                     const currentTime = wavesurfer.getCurrentTime();
                     currentTimeDisplay.textContent = formatTime(currentTime);
                     const duration = wavesurfer.getDuration();
                     if (typeof duration === 'number' && duration > 0) {
                         const percentage = (currentTime / duration) * 100;
                         progressBar.style.width = `${Math.min(percentage, 100)}%`;
                     }
                });

                wavesurfer.on('finish', function() {
                    // Al terminar reproducción
                    console.log("Playback finished");
                    isPlaying = false;
                    playIcon.style.display = 'block';
                    pauseIcon.style.display = 'none';
                    progressBar.style.width = '100%';
                    currentTimeDisplay.textContent = formatTime(wavesurfer.getDuration());
                });

                wavesurfer.on('error', function(err) {
                    // Manejo de errores
                    console.error('WaveSurfer error:', err);
                    errorMessage.textContent = `Error al cargar audio: ${err}`;
                    errorMessage.style.display = 'block';
                    playButton.disabled = true; // Mantener deshabilitado
                    playButton.title = "Error al cargar audio";
                    durationDisplay.textContent = '00:00';
                    currentTimeDisplay.textContent = '00:00';

                    // --- Quitar indicadores de carga y poner estado de error ---
                    progressBar.classList.remove('loading');
                    progressBar.classList.add('error'); // Añadir clase de error
                    waveformContainer.classList.remove('loading'); // Ocultar puntos
                    // Opcional: Mostrar icono/mensaje de error en el área de la onda
                    waveformContainer.innerHTML = '<span style="color: var(--error-color); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">⚠ Error</span>';
                });
            }

            // --- Funciones Auxiliares --- (Sin cambios extractAndFormatDate, searchAvailablePodcasts, procesarPodcastsEncontrados, updateArchiveList, formatTime)
             function extractAndFormatDate(filename) {
                const pattern = /(\d{2})\.(\d{2})\.(\d{4})\.mp3$/;
                const match = filename.match(pattern);
                if (!match) return null;
                const day = match[1], month = match[2], year = match[3];
                const date = new Date(Date.UTC(year, parseInt(month) - 1, day));
                 if (isNaN(date.getTime()) || date.getUTCDate() !== parseInt(day) || date.getUTCMonth() !== parseInt(month) - 1 || date.getUTCFullYear() !== parseInt(year)) {
                     console.warn(`Invalid date extracted from "${filename}"`); return null;
                 }
                const monthNames = ['Enero', 'Febrero', 'Marzo', 'Abril', 'Mayo', 'Junio', 'Julio', 'Agosto', 'Septiembre', 'Octubre', 'Noviembre', 'Diciembre'];
                return { displayDate: `${date.getUTCDate()} de ${monthNames[date.getUTCMonth()]}, ${date.getUTCFullYear()}`, dateObj: date, filename: filename };
            }
            function searchAvailablePodcasts() {
                archiveList.innerHTML = '<li class="archive-item">Buscando resúmenes...</li>';
                let foundPodcasts = [];
                const filesToCheck = [ 'reporte_semanal_16.03.2025.mp3', 'reporte_semanal_09.03.2025.mp3', 'resumen_especial_15.03.2025.mp3', 'reporte_semanal_30.03.2025.mp3', 'reporte_semanal_23.03.2025.mp3', 'reporte_semanal_08.02.2025.mp3', 'reporte_1trimestre_01.04.2025.mp3', 'archivo_sin_fecha.mp3', 'no_existe_20.03.2025.mp3' ];
                let pendingChecks = filesToCheck.length, checkedCount = 0;
                console.log(`Checking ${pendingChecks} potential files...`);
                if (pendingChecks === 0) { procesarPodcastsEncontrados([]); return; }
                filesToCheck.forEach(filename => {
                    const xhr = new XMLHttpRequest(); xhr.open('HEAD', filename, true); xhr.timeout = 5000;
                    xhr.onreadystatechange = function() {
                        if (xhr.readyState === 4) {
                            checkedCount++;
                            if (xhr.status === 200) {
                                const podcastInfo = extractAndFormatDate(filename);
                                if (podcastInfo) { foundPodcasts.push(podcastInfo); }
                                else { console.log(`File "${filename}" found but ignored (invalid date format).`); }
                            }
                            if (checkedCount === pendingChecks) { console.log("Finished checking all files."); procesarPodcastsEncontrados(foundPodcasts); }
                        }
                    };
                     xhr.onerror = function() { checkedCount++; console.error(`Network error checking "${filename}". Check CORS policy.`); if (checkedCount === pendingChecks) { console.log("Finished checking all files (with network errors)."); procesarPodcastsEncontrados(foundPodcasts); } };
                     xhr.ontimeout = function () { checkedCount++; console.warn(`Timeout checking "${filename}".`); if (checkedCount === pendingChecks) { console.log("Finished checking all files (with timeouts)."); procesarPodcastsEncontrados(foundPodcasts); } };
                    xhr.send(null);
                });
            }
             function procesarPodcastsEncontrados(podcasts) {
                console.log(`Processing ${podcasts.length} valid podcasts found.`);
                if (podcasts.length === 0) {
                    archiveList.innerHTML = '<li class="archive-item not-available">No hay resúmenes disponibles</li>';
                    errorMessage.textContent = 'No se encontraron archivos de audio válidos.'; errorMessage.style.display = 'block';
                    playButton.disabled = true; playButton.title = "No hay audio disponible";
                    podcastTitleDisplay.textContent = "Sin Audio"; podcastDateDisplay.textContent = "---";
                    durationDisplay.textContent = '00:00'; currentTimeDisplay.textContent = '00:00';
                     // Limpiar área de onda en caso de error inicial sin podcasts
                     waveformContainer.innerHTML = '';
                     progressBar.classList.add('error'); // Marcar barra como error
                } else {
                    podcasts.sort((a, b) => b.dateObj - a.dateObj);
                    updateArchiveList(podcasts);
                    loadPodcast(podcasts[0]); // Cargar el más reciente
                    playButton.disabled = true; // Deshabilitado hasta que 'ready'
                    playButton.title = "Cargando audio y onda...";
                    errorMessage.style.display = 'none';
                }
            }
            function updateArchiveList(podcasts) {
                archiveList.innerHTML = '';
                podcasts.forEach((podcast, index) => {
                    const li = document.createElement('li'); li.className = 'archive-item';
                    if (index === 0) li.classList.add('active');
                    li.dataset.filename = podcast.filename; li.title = `Reproducir: ${podcast.filename}`;
                    li.innerHTML = `<span class="archive-item-icon"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon></svg></span><span class="archive-item-date">${podcast.displayDate}</span>`;
                    li.addEventListener('click', () => {
                         if (currentPodcastInfo && currentPodcastInfo.filename === podcast.filename) return;
                         const clickedPodcastInfo = podcasts.find(p => p.filename === li.dataset.filename);
                         if (clickedPodcastInfo) { loadPodcast(clickedPodcastInfo); }
                    });
                    archiveList.appendChild(li);
                });
            }
             function formatTime(seconds) {
                 if (isNaN(seconds) || seconds === Infinity || seconds < 0) return '00:00';
                const minutes = Math.floor(seconds / 60); const remainingSeconds = Math.floor(seconds % 60);
                return `${String(minutes).padStart(2, '0')}:${String(remainingSeconds).padStart(2, '0')}`;
            }


            // --- Funciones de Control ---

            function togglePlayPause() {
                if (!wavesurfer || !wavesurfer.isReady) { console.warn("WaveSurfer not ready to play/pause."); return; }
                if (isPlaying) {
                    wavesurfer.pause(); playIcon.style.display = 'block'; pauseIcon.style.display = 'none';
                } else {
                    wavesurfer.play(); playIcon.style.display = 'none'; pauseIcon.style.display = 'block';
                }
                isPlaying = !isPlaying;
            }

            function loadPodcast(podcastInfo) {
                if (!podcastInfo || !podcastInfo.filename) { console.error("Invalid podcast info provided."); errorMessage.textContent = 'Error interno.'; errorMessage.style.display = 'block'; return; }

                 console.log(`Attempting to load: ${podcastInfo.filename}`);
                 currentPodcastInfo = podcastInfo;
                 isPlaying = false; // Reset play state
                 playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; // Reset icons

                 // --- Establecer Estado Visual de Carga ---
                 errorMessage.style.display = 'none'; // Ocultar errores previos
                 podcastDateDisplay.textContent = podcastInfo.displayDate;
                 podcastTitleDisplay.textContent = "Cargando audio y onda..."; // Nuevo texto de carga
                 playButton.disabled = true; // DESHABILITAR PLAY
                 playButton.title = "Cargando audio y onda...";
                 currentTimeDisplay.textContent = '00:00'; durationDisplay.textContent = '00:00';
                 progressBar.style.width = '0%'; // Iniciar barra en 0%
                 progressBar.classList.remove('error'); // Quitar posible estado de error
                 progressBar.classList.add('loading'); // Añadir clase para animación y color de carga
                 waveformContainer.classList.add('loading'); // Mostrar animación de puntos
                 // Limpiar contenido anterior de waveform por si hubo error previo
                 waveformContainer.innerHTML = '';


                 // Actualizar clase 'active' en la lista
                 document.querySelectorAll('#archive-list .archive-item').forEach(item => {
                     item.classList.toggle('active', item.dataset.filename === podcastInfo.filename);
                 });

                try {
                    // Iniciar carga en WaveSurfer (los eventos 'loading', 'ready', 'error' manejarán el resto)
                    wavesurfer.load(podcastInfo.filename);
                } catch (error) {
                    console.error('Error initiating WaveSurfer load:', error);
                    errorMessage.textContent = 'Error al intentar iniciar la carga.'; errorMessage.style.display = 'block';
                    playButton.disabled = true; playButton.title = "Error al cargar audio";
                    progressBar.classList.remove('loading'); progressBar.classList.add('error');
                    waveformContainer.classList.remove('loading');
                    waveformContainer.innerHTML = '<span style="color: var(--error-color); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">⚠ Error</span>';
                    podcastTitleDisplay.textContent = "Error";
                }
            }

            function updateVolumeIcon() {
                if (!wavesurfer) { /* Estado inicial antes de cargar */
                     volumeIcon.style.display = 'block'; muteIcon.style.display = 'none';
                     volumeLow.style.display = 'none'; volumeHigh.style.display = 'block'; return;
                }
                const mutedState = wavesurfer.getMute(); // Corregido
                const currentVolume = wavesurfer.getVolume();
                if (mutedState || currentVolume < 0.01) {
                    volumeIcon.style.display = 'none'; muteIcon.style.display = 'block';
                } else {
                    volumeIcon.style.display = 'block'; muteIcon.style.display = 'none';
                    if (currentVolume < 0.5) { volumeLow.style.display = 'block'; volumeHigh.style.display = 'none'; }
                    else { volumeLow.style.display = 'block'; volumeHigh.style.display = 'block'; }
                }
            }

            function toggleMute() {
                if (!wavesurfer) return;
                isMuted = !isMuted;
                wavesurfer.setMute(isMuted); // Corregido
                if (isMuted) {
                    previousVolume = parseFloat(volumeSlider.value); volumeSlider.value = 0;
                } else {
                     const restoreVolume = previousVolume > 0 ? previousVolume : 1;
                     volumeSlider.value = restoreVolume; wavesurfer.setVolume(restoreVolume);
                }
                updateVolumeIcon();
            }

            // --- Event Listeners ---
            playButton.addEventListener('click', togglePlayPause);
            muteButton.addEventListener('click', toggleMute);
            volumeSlider.addEventListener('input', function() {
                if (!wavesurfer) return;
                const volumeValue = parseFloat(this.value); wavesurfer.setVolume(volumeValue);
                if (volumeValue > 0) {
                    if (isMuted) { isMuted = false; wavesurfer.setMute(false); } // Corregido
                } else {
                    if (!isMuted) { isMuted = true; wavesurfer.setMute(true); } // Corregido
                }
                updateVolumeIcon();
            });
            progressContainer.addEventListener('click', function(e) {
                 if (!wavesurfer || !wavesurfer.isReady) return;
                 const bounds = this.getBoundingClientRect();
                 const clickPositionX = e.clientX - bounds.left;
                 const relativePosition = Math.max(0, Math.min(1, clickPositionX / bounds.width));
                 wavesurfer.seekTo(relativePosition);
            });

            // --- Inicialización ---
            console.log("DOM fully loaded and parsed.");
            initWaveSurfer();
            searchAvailablePodcasts(); // Inicia la búsqueda y carga del primer podcast
            updateVolumeIcon(); // Establece icono de volumen inicial

        }); // Fin DOMContentLoaded
    </script>
</body>
</html>
